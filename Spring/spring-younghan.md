### 스프링 부트

- 스프링 부트가 제공하는 Welcome Page 기능

  > 'static/index.html'을 올려두면 Welcome page 기능을 제공한다

- thymeleaf 템플릿 엔진



- 컨트롤러에서 리턴 값으로 문자를 반환하면 뷰 리졸버가 화면을 찾아서 처리한다

  > 스프링 부트 템플릿엔진 기본 viewName 매핑
  >
  > 'resources:templates/'+{ViewName}+'.html'





- 테스트케이스 작성

  > 우리가 main메소드에서 실행해서 직접 에러를 겪어보거나 컨트롤러에서 해당 기능을 실행해보면서 에러를 찾는 경우도 있는데 이 경우에는 준비나 실행시간이 오래 걸리고, 반복 실행하기 어렵고 여러 테스트를 한번에 실행하기 어렵다는 단점이 있음.
  >
  > 그래서 자바는 JUnit이라는 프레임워크로 테스트를 실행해서 이러한 문제를 해결



스프링이 실행될때 어노테이션 컨트롤러, 컴포넌트, 서비스, 리포지토리를 읽어서 Bean으로 등록해준다.



참고 : 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때, 기본으로 싱글톤 (즉 하나만)으로 등록한다.

유일하게 하나만 등록해서 서로 공유한다. 따라서 같은 스프링 빈이면 모두 같은 인스턴스다. 설정으로 싱글톤이 아니게 설정할 수 있지만, 특별한 경우를 제외하면 대부분 싱글톤으로 사용한다.



#### Bean으로 등록하는 것과 @Service, @Controller, @Repository의 차이점

- Di에는 생성자 주입, 필드 주입, Setter 주입이 존재한다.

  > 필드 주입은 별로 안좋다. 이유는 한번 셋팅이 되고나서 중간에 바꿀 방법이 없다.
  >
  > 요즘 권장하는 스타일은 생성자를 통해 DI 주입하는게 가장 좋다.
  >
  > 그래야지 셋팅을 다하고나서 스프링이 구동되고나서 그때 객체 생성하면서 한번 주입되고 끝나기 떄문
  >
  > 세터 인젝션은 누군가가 그냥 그 Autowired가 걸려있는 세터를 마음대로 호출해서 변경을 할 수도 있기 때문이다.



- 정형화된 컨트롤러, 서비스, 리포지토리같은 코드는 컴포넌트 스캔을 사용한다. But 정형화 되지않거나 , 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록하는게 좋다.
- 우리가 나중에 할 것이 가상화 데이터베이스를 지정한 MemoryMemberRepository를 다른 코드들을 일절 건드리지않고 바꾸는 일을 할텐데 이럴때 차이점이 발생하게 된다. (정형화 되지 않았다는 의미가 DB를 뭘 쓸지를 정하지 않았을 경우)



##### @Component, @Service, @Controller, @Repository, @Bean, @Autowired

- 스프링이 구동될때 어노테이션들을 전부다 읽어 들인다.

  > 그때 @Component, @Service, @Controller, @Repository, @Bean들은 모두 스프링 컨테이너에 객체로 생성이 된다. 
  >
  > 그리고나서 @Autowired를 DI를 통해 주입을 시켜주는데 그때 주입시키는 **객체들이 꼭 반드시 스프링 컨테이너에 객체로 등록되어 있어야한다. **



#### index

- 스프링 부트가 실행되면 스프링 컨테이너에 컨트롤러를 찾는데 메인 페이지도 부트가 실행이되면 루트라는 경로가 없으면 index.html을 찾지만 만약 루트라는 맵핑이 있으면 그걸 우선으로 찾는다.





#### interface

객체지향 설계가 왜 좋냐?

> 다형성을 활용한다고 한다.
>
> 인터페이스를 두고 구현체를 바꿔 끼우기가 쉽다. 
>
> 스프링을 이 과정(구현체 바꾸기)을 굉장이 편리하게 해준다. 스프링 컨테이너가 지원해준다. DI 때문에도 더 편하다.

> 스프링 DI를 사용하면 **기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경 할 수 있다.**





- @SpringBootTest : 스프링 컨테이너와 테스트를 함께 실행한다.
- @Transactional : 테스트 케이스에 이 어노테이션이 있으면, 테스트 시작 전에 트랜잭션을 시작하고, 테스트 완료 후에 항상 롤백한다. 이렇게 하면 DB에 데이터가 남지 않으므로 다음 테스트에 영향을 주지 않는다.
- 테스트 케이스에서 Transaction을 걸어도 커밋할 수 있다 테스트 메소드에 @Comit이라는 어노테이션이 존재한다.
- ***테스트 케이스에 붙었을때만 롤백이 된다. Service단 이런데에 붙여도 정상적으로 디비에 값이 들어간다***





#### jpa

- spring.jpa.show-sql : jpa가 날려주는 쿼리를 볼 수 있다. (true)
- spring.jpa.hibernate.ddl-auto=none : 기존에 만들어져 있는 테이블을 사용할거라서 none으로 jpa가 자동으로 테이블을 생성해주는 기능은 끈다. create시 테이블 자동생성 해줌



#### 스프링 데이타 Jpa

- 우리가 Jpa에서 사용했던 쿼리문 조차 인터페이스로 부트가 자동으로 구현체를 만들어준다
- 기본적인 CRUD등등 많은 구현체가 있다.
- 우리가 필요한 Name, Email을 통해 검색하는 메소드들은 findByOOO 이런식으로 쉽게 규칙만 맞춰주면 구현이 가능하다.
- 하지만 그래도 인프런 김영한님 강의를 통해 깊게 공부하는게 정말 좋다.



### AOP

- 공통적인 사용이 필요할때 사용한다.
- ex) 모든 메서드들의 실행시간을 알고 싶다? 하면 모든 메서드에 실행 시간을 구현해주어야한다. 이럴경우 정말 효율도 안 좋다. (유지보수도 안 좋다.)
- ex에서 추가 설명 시간을 측정하는 로직은 핵심 로직이 아니다. 공통 관심 사항이다.
- 유지보수가 안좋은 이유는 공통 로식 사항이 핵심 로직 사항이랑 섞여 있기 때문이다.
- 핵심 로직 사항은 우리가 만든 구현체들이다.
- 핵심 관심 사항 CC , 공통 관심 사항 CCC
- 결론 : AOP를 구현 해두면 핵심 관심 사항의 코드를 깔끔하게 유지 가능하며 변경이 필요하면 공통 관심 사항 로직만 바꾸어주면 된다. 그리고 원하는 적용 대상을 선택할 수 있다.